#!/usr/bin/perl

use strict;
use warnings;

# check if modules exist
eval { require XML::Simple; };
if ($@) { die "[*]: $0: ERROR: require module XML::Simple: can't load module $@\n on CentOS: yum install perl-XML-Simple";}

eval { require utf8; };
if ($@) { die "[*]: $0: ERROR: require module utf8: can't load module $@\n on CentOS: yum install perl-utf8-all";}

eval { require Mail::Sendmail; };
if ($@) { die "[*]: $0: ERROR: require module Mail::Sendmail: can't load module: $@\n on CentOS: yum install perl-Mail-Sendmail";}

use utf8;
use XML::Simple;
use Data::Dumper 'Dumper';
use POSIX qw(strftime);
use Mail::Sendmail;

binmode(STDIN,  ':encoding(utf8)');
binmode(STDOUT, ':encoding(utf8)');
binmode(STDERR, ':encoding(utf8)');

# http://www.allmyscripts.com/Perl_programming/remove_duplicates.html
#sub uniq_array
#{
#        my @a = @_;
#        my %seen = ();
#        my @result = grep { !$seen{$_}++ } @a;
#        return (@a);
#}
sub uniq {
  my (@input) = @_;
  my %all = ();
  @all{@input} = 1;
  return (keys %all);
}

my $date_year      = strftime "%y", (localtime(time()) );
my $date_today     = strftime "%Y-%m-%d", (localtime(time()) );
my $date_yesterday = strftime "%Y-%m-%d", ( localtime (time() - 24*60*60) );
my $xml            = XML::Simple->new;

my %recent         = ();
my $ref;

my  $alert = '';

my @numbers;

# we need 2 digits
for my $num ( 0 .. $date_year )
{
        my $str = sprintf ("%02d",$num);
        push (@numbers, $str);
}

foreach my $n ( @numbers  )
{
        if (not($ref = XMLin("/var/www/SITES/secalert.sec.domain.com/data/DEBIAN/oval-definitions-20" . $n . ".xml",ForceArray => [ 'reference', 'platform' ])))
        {
                print ("[*]: $0: ERROR: XMLin: Could not parse file: $!\n");
                next;
        }


        # loop through all entries
        foreach my $cve ( sort keys %{ $ref->{definitions}->{definition} } ) {

                # define the entry
                my $entry = $ref->{definitions}->{definition}->{$cve};

                # we need this in the beginning so we cam match dates
                my $date  = "NA";
                if ( defined ( $entry->{'metadata'}->{'debian'}->{'date'} ))
                {
                        $date = $entry->{'metadata'}->{'debian'}->{'date'};
                }


                # CVE ID and TITLE
                my $title    = "NA";
                my ( $year, $num ) = 'NA';
                if ( defined ( $entry->{'metadata'}->{'title'} ) )
                {
                        $title        = $entry->{'metadata'}->{'title'};
                }
                $alert .= "\nID: $title\n";


                # DESCRIPTION
                my $description = "NA";
                if ( defined ( $entry->{'metadata'}->{'description'}) )
                {
                        # sometimes we see empty hash in the description
                        if ( ref ( $entry->{'metadata'}->{'description'} ) ne 'HASH' )
                        {
                                $description = $entry->{'metadata'}->{'description'};
                        }
                }
                $alert .= "DESCRIPTION: " . $description . "\n";


                $alert .= "DATE: " . $date . "\n";


                # CLASS
                my $class = "NA";
                if ( defined ( $entry->{'class'} ))
                {
                        $class = $entry->{'class'} ;
                }
                $alert .= "CLASS: " . $class . "\n";




                # REFERENCE URLs
                my ( @ref_urls ) = ();
                if (defined ($entry->{metadata}->{reference}))
                {
                        if ( ref ( $entry->{metadata}->{reference}) eq 'ARRAY' )
                        {
                                # this needs ForceArray in the XMLin options
                                foreach my $reference ( @{ $entry->{metadata}->{reference} })
                                {
                                        if ( defined ( $reference->{ref_url} ) )
                                        {
                                                push ( @ref_urls, $reference->{ref_url} );
                                        }
                                        #print Dumper($reference);
                                }
                        } else {
                               push ( @ref_urls, $entry->{metadata}->{reference}->{ref_url} );
                        }
                        $alert .= "REF_URLs:\n" . join ( "\n", @ref_urls ) . "\n";
                }



                # Platform
                my @platform = ();
                if ( defined ($entry->{'metadata'}->{'affected'}->{'platform'} ) )
                {
                        if ( ref ( $entry->{'metadata'}->{'affected'}->{'platform'} ) eq 'ARRAY')
                        {
                                foreach my $platform_element ( @{ $entry->{'metadata'}->{'affected'}->{'platform'} } )
                                {
                                        push ( @platform, $platform_element );
                                }
                        } else {
                                push (@platform, $entry->{'metadata'}->{'affected'}->{'platform'} );
                        }
                        $alert .= "PLATFORM: " . join (",", @platform ) . "\n";
                }

                $alert .= "\n\n";
        }

}

if ( length ($alert) > 100)
{
        print $alert;
        my %mail = (
            from => 'securityteam@domain.com',
            to => 'securityteam@domain.com',
            subject => "Vulnerability report for DEBIAN, published $date_yesterday and $date_today"
        );

        $mail{body}=$alert;
        sendmail(%mail) || print "Error in sending email\n";

}

