#!/usr/bin/perl

use strict;
use warnings;

# check if modules exist
eval { require XML::Simple; };
if ($@) { die "[*]: $0: ERROR: require module XML::Simple: can't load module $@\n on CentOS: yum install perl-XML-Simple";}

eval { require utf8; };
if ($@) { die "[*]: $0: ERROR: require module utf8: can't load module $@\n on CentOS: yum install perl-utf8-all";}

eval { require Mail::Sendmail; };
if ($@) { die "[*]: $0: ERROR: require module Mail::Sendmail: can't load module: $@\n on CentOS: yum install perl-Mail-Sendmail";}

use utf8;
use XML::Simple;
use Data::Dumper 'Dumper';
use POSIX qw(strftime);
use Mail::Sendmail;

binmode(STDIN,  ':encoding(utf8)');
binmode(STDOUT, ':encoding(utf8)');
binmode(STDERR, ':encoding(utf8)');

# http://www.allmyscripts.com/Perl_programming/remove_duplicates.html
#sub uniq_array
#{
#        my @a = @_;
#        my %seen = ();
#        my @result = grep { !$seen{$_}++ } @a;
#        return (@a);
#}
sub uniq {
  my (@input) = @_;
  my %all = ();
  @all{@input} = 1;
  return (keys %all);
}

#my %colors = (
#        W  => "\033[0m",  # white (normal)
#        R  => "\033[31m", # red
#        G  => "\033[32m", # green
#        O  => "\033[33m", # orange
#        B  => "\033[34m", # blue
#        P  => "\033[35m", # purple
#        C  => "\033[36m", # cyan
#        GR => "\033[37m", # gray
#        BB => "\033[1m",  # Bold
#        NB => "\033[0m",  # Not bold
#        F  => "\033[5m",  # Flash
#        NF => "\033[25m"  # Not flash
#);
#print $colors{R} . "TEST" . $colors{W} . "\n";

my $date_today     = strftime "%Y-%m-%d", (localtime(time()) );
my $date_yesterday = strftime "%Y-%m-%d", ( localtime (time() - 24*60*60) );
my $xml            = XML::Simple->new;

my %recent         = ();
my $ref;

my %cve = ();
my @numbers;

# we need 2 digits
my $date_year      = strftime "%y", (localtime(time()) );
for my $num ( 0 .. $date_year )
{
        my $str = sprintf ("%02d",$num);
        push (@numbers, $str);
}

foreach my $n ( @numbers  )
{
        # skip if file does not exist
        next if ( ! -f "/var/www/SITES/secalert.sec.domain.com/data/NVD/nvdcve-2.0-20". $n .".xml" );

        print "[*] $0: INFO: loading " . "/var/www/SITES/secalert.sec.domain.com/data/NVD/nvdcve-2.0-20". $n .".xml\n";
        if (not($ref = XMLin("/var/www/SITES/secalert.sec.domain.com/data/NVD/nvdcve-2.0-20" . $n .".xml")))
        {
                print ("[*]: $0: ERROR: XMLin: Could not parse file: $!\n");
                next;
        }


        # attributes for each entry
        my @must       = ('vuln:cve-id', 'vuln:published-datetime', 'vuln:last-modified-datetime', 'vuln:summary');
        my @cvss       = ('cvss:score', 'access-vector', 'cvss:access-complexity', 'cvss:authentication', 'cvss:confidentiality-impact', 'cvss:integrity-impact', 'cvss:source', 'cvss:generated-on-datetime' );


        # loop through all entries
        for my $cve (sort keys %{$ref->{entry}})
        {

                # define the entry
                my $entry = $ref->{entry}->{$cve};

                if (! exists $entry->{'vuln:cve-id'} )
                {
                        print "[*]: $0: ERROR: vuln:cve-id attribute MUST exist for each entry!\n";
                        next;
                }

                if ($entry->{'vuln:cve-id'} !~ m/^CVE-\d+-\d+$/)
                {
                        print "[*]: $0: ERROR: malformed CVE - use CVE-2016-12345\n";
                        next;
                }

                my $cveid = $entry->{'vuln:cve-id'};    # CVE: shortcut

                # skip processing in certain cases
                if ( exists ($entry->{'vuln:summary'}) && ( $entry->{'vuln:summary'} =~ m/DO\s+NOT\s+USE\s+THIS\s+CANDIDATE\s+NUMBER/) )
                {
                        next;
                }


                $cve{$cveid}{'cveid'}      = $cveid;    # CVE: store id
                $cve{$cveid}{'urls'}       = [];        # CVE: empty array for url references
                $cve{$cveid}{'products'}   = [];        # CVE: empty array for products
                $cve{$cveid}{'sources'}    = [];        # CVE: empty array for sources
                $cve{$cveid}{'urls'}       = [];        # CVE: empty array for urls (references)
                $cve{$cveid}{'numurls'}    = 0;         # CVE: set number of urls to 0
                $cve{$cveid}{'url'}        = 'https://web.nvd.nist.gov/view/vuln/detail?vulnId=';
                $cve{$cveid}{'url'}       .= $cveid;    # CVE: set web url


                # must attributes
                foreach my $attribute (@must)
                {

                        if (! exists $entry->{$attribute})
                        {
                                #print $entry->{$attribute} . ":::";
                                print "[*]: $0: ERROR: attribute '$attribute' undefined\n";
                                next;
                        }
                        $cve{$cveid}{$attribute}   = $entry->{$attribute};   # CVE: store attributes defined in @must array

                        # limit length to 8000 bytes
                        if (length ($cve{$cveid}{$attribute}) > 8000)
                        {
                                        $cve{$cveid}{$attribute} = substr($cve{$cveid}{$attribute}, 0, 8000);
                        }

                }




                # overide vuln:published-datetime
                my ($pubdate, $pubtime)                 = ($entry->{'vuln:published-datetime'} =~ m{(\d{4}-\d{2}-\d{2})(?:T)(\d{2}:\d{2}:\d{2})} ); 
                $cve{$cveid}{'vuln:published-datetime'}      = $pubdate . " " . $pubtime;

                # overide vuln:last-modified-datetime
                my ($lastmoddate,$lastmodtime)          = ($entry->{'vuln:last-modified-datetime'} =~ m{(\d+-\d+-\d+)(?:T)(\d+:\d+:\d+)});
                $cve{$cveid}{'vuln:last-modified-datetime'}  = $lastmoddate . " " . $lastmodtime;

                # recent: yesterday + today
                if ( ( $lastmoddate =~ m/$date_today|$date_yesterday/) || ($pubdate =~ m/$date_today|$date_yesterday/) )
                {
                        $recent{$cveid} = 1;
                }


                # PRODUCTS
                my @products;
                if (exists $entry->{'vuln:vulnerable-software-list'}->{'vuln:product'})
                {
                        if ("ARRAY" eq ref $entry->{'vuln:vulnerable-software-list'}->{'vuln:product'})
                        {
                                @products = @{$entry->{'vuln:vulnerable-software-list'}->{'vuln:product'}};
                        } else {
                                @products = ($entry->{'vuln:vulnerable-software-list'}->{'vuln:product'});
                        }
                        map {s/cpe:\/a://g; } @products;
                        map {s/cpe:\/h://g; } @products;
                        map {s/cpe:\/o://g; } @products;
                        #print "PRODUCTS: @products\n";
                        #push ( @{$cve{$attribute}}, $entry->{$attribute} );
                        @products = &uniq(@products);
                        $cve{$cveid}{products}   = [@products];   # CVE: store cvss attributes
                } else {
                        $cve{$cveid}{products}   = [ "NA" ];   # CVE: store cvss attributes
                }


                # CVSS  Defaults score to NA if not set
                #        $cve{$cveid}{cvss}{'cvss:score'} = 'NA';
                foreach my $cvss_attribute (@cvss)
                {
                        if (exists $entry->{'vuln:cvss'}->{'cvss:base_metrics'}->{$cvss_attribute})
                        {
                                $cve{$cveid}{cvss}{$cvss_attribute}   = $entry->{'vuln:cvss'}->{'cvss:base_metrics'}->{$cvss_attribute};   # CVE: store cvss attributes
                                #print "CVSS ATTR: $cvss_attribute: " . $entry->{'vuln:cvss'}->{'cvss:base_metrics'}->{$cvss_attribute} . "\n";
                        }
                }


                # CWE-ID
                if (exists $entry->{'vuln:cwe'})
                {
                        $cve{$cveid}{'cweid'}   = $entry->{'vuln:cwe'}->{'id'};   # CVE: store CWE attribute
                }

                #push @{ $HoA{"flintstones"} }, "wilma", "betty";
                # REFERENCES, sources
                my @urls    = ();
                my @sources = ();
                if (defined($entry->{'vuln:references'}))
                {
                        if ( ref($entry->{'vuln:references'}) eq 'ARRAY')
                        {

                                # multiple entries, let's do a loop
                                foreach my $loop ( @{$entry->{'vuln:references'}} )
                                {
                                        # vuln:source
                                        if ( exists $loop->{'vuln:source'} )
                                        {
                                                #print "vuln:source: " . $loop->{'vuln:source'} . "\n";
                                                push ( @sources, $loop->{'vuln:source'} );
                                        }

                                        # vuln: reference
                                        if ( exists $loop->{'vuln:reference'}->{href} )
                                        {
                                                push ( @urls, $loop->{'vuln:reference'}->{href} );
                                                #print "vuln:reference: " . $loop->{'vuln:reference'}->{href} . "\n";
                                        }

                                }
                        } else {
                                # single entries
                                #print "vuln:source " . $entry->{'vuln:references'}->{'vuln:source'} . "\n";
                                push (@sources, $entry->{'vuln:references'}->{'vuln:source'});
                                #print "vuln:reference " . $entry->{'vuln:references'}->{'vuln:reference'}->{href} . "\n";
                                push (@urls, $entry->{'vuln:references'}->{'vuln:reference'}->{href});
                        }

                        if ( scalar (@sources) > 0)
                        {
                                @sources = &uniq(@sources);
                                $cve{$cveid}{sources}  = [@sources];      # CVE: store sources in array
                        }

                        if ( scalar (@urls) > 0 )
                        {
                                @urls = &uniq(@urls);
                                $cve{$cveid}{urls}     = [@urls];         # CVE: store urls (references) in array
                                $cve{$cveid}{numurls}  = scalar (@urls);  # CVE: set number of urls
                                #print (join("\n", @urls)."\n");
                        }
                } else {
                                $cve{$cveid}{urls}     = [ "NA" ];         # CVE: store urls (references) in array
                }
        }
}

#print Dumper(%cve);
#print Dumper(%recent);

# recent ( yesterday + today )
if ( scalar (keys %recent) > 0 )
{
        my $text = "\nVulnerability report for NVD, published $date_yesterday and $date_today\n\n";

        foreach my $v ( sort keys %recent )
        {
                $cve{$v}{'cvss'}{'cvss:score'} ||= "NA";
                $cve{$v}{'vuln:published-datetime'} ||= "NA";
                $cve{$v}{'vuln:last-modified-datetime'} ||= "NA";

                $text .= "\n";

                $text .= "ID:             "   . $v . "\n";
                $text .= "SUMMARY:        "   . $cve{$v}{'vuln:summary'} . "\n";
                $text .= "SCORE:          "   . $cve{$v}{'cvss'}{'cvss:score'} . "\n";
                $text .= "PRODUCTS:\n"        . join ( "\n", @{ $cve{$v}{products} } )  . "\n";
                $text .= "SOURCES:\n"         . join ( "\n", @{ $cve{$v}{sources} } )   . "\n";
                $text .= "REFERENCES:\n"      . join ( "\n", @{ $cve{$v}{urls} } )      . "\n";
                $text .= "DATE-PUBLISHED: "   . $cve{$v}{'vuln:published-datetime'}     . "\n";
                $text .= "DATE-MODIFIED:  "   . $cve{$v}{'vuln:last-modified-datetime'} . "\n";

                $text .= "\n";
        }
        $text .= "\n\n";

        print $text;

        my %mail = (
            from => 'securityteam@domain.com',
            to => 'securityteam@domain.com',
            subject => "Vulnerability report for NVD, published $date_yesterday and $date_today"
        );
        $mail{body}=$text;
        sendmail(%mail) || print "Error in sending email\n";


        print "\n";


        # COMPANY TARGETTED REPORT: send each team indivual emails based on /vendors/products used
        my %cpe_settings =
        (
            win             => [ "microsoft:", "cisco:unified_communications_manager", "cisco:ucs", "samba:samba:", "squid-cache:squid:", "vmware:", "microsoft:sql_server:" ],
            networkteam     => [ "cisco:ios", "cisco:nx-os", "cisco:asr", "cisco:xr", "cisco:unified_communications_manager:", "cisco:ucs", "cisco:nexus" , 
                                 "f5:", "phpipam:phpipam:", "dokuwiki:dokuwiki:", "arbor_networks:peakflow_sp:", "shrubbery:rancid:", "cacti:cacti:", "cisco:1941"
                               ],
            webteam         => [ "php:php:5.6", "php:php:7", "apache:http_server:", "microsoft:frontpage:", "proftpd:proftpd:" ],
            releasemanagers => [ "atlassian:jira:", "atlassian:crowd:", "atlassian:confluence:", "jenkins:jenkins:" ],
            storage         => [ "netapp:" ],
            fax2email       => [ "digium:asterisk:", "imagemagick:imagemagick:", "apache:http_server:", "zabbix:zabbix:" ],
            sql             => [ "apache:hadoop:", "mariadb:mariadb:", "apache:ambari:", "hp:vertica:", "oracle:mysql:", "cacti:cacti:", "microsoft:sql_server:", "mongodb:mongodb:" ],
            puppetmasters   => [ "gitlab:gitlab:", "apache:http_server:", "collectd:collectd:", "isc:bind:", "isc:dhcp", "openssl:openssl:", "puppetlabs:puppet",
                                 "torch_gmbh:graylog2:", "elasticsearch:logstash:", "elasticsearch:elasticsearch:"
                               ],
            monitoringteam  => [ "nagios:nagios:", "icinga:icinga:", "zabbix:zabbix:", "net-snmp:net-snmp:", "oracle:mysql:", "pnp4nagios:pnp4nagios:", "rrdtool_project:rrdtool:" ],
            dns             => [ "isc:bind:" ],
            mailteam        => [ "nginx:nginx:", "php:php:5.6", "php:php:7", "apache:http_server:", "pivotal_software:redis:", "powerdns:recursor:", "commtouch:", "sendmail:sendmail:", "oracle:mysql:"],
            securityteam    => [ "alienvault:", "ansibleworks:ansible:", "apache:http_server:", "drupal:drupal:", "emc:rsa", "gnu:bash:", "gnu:glibc",
                                 "haxx:curl:", "haxx:libcurl:", "joomla:joomla:", "linux:linux_kernel:", "nodejs:node.js:", "npm:npm:", "paloaltonetworks:",
                                 "phpmyadmin:phpmyadmin:", "pulsesecure:pulse_connect_secure:", "squid-cache:squid:", "tenable:nessus:", "wordpress:wordpress:",
                                 "dokuwiki:dokuwiki:" , "elasticsearch:kibana:", "elasticsearch:elasticsearch:", "modpagespeed:mod_pagespeed:", "cacti:cacti:",
                                 "proftpd:proftpd:", "gnu:gnutls", "apache:mod_perl", "openbsd:openssh:", "kernel:linux-pam:", "apache:struts2", "openldap:openldap:",
                                 "fedoraproject:sssd", "mozilla:nss:", "rsyslog:rsyslog:", "net-snmp:net-snmp:"
                               ],
        );

        foreach my $v ( sort keys %recent )
        {

                # skip in certain instances
                next if ( $cve{$v}{'vuln:summary'} =~ m/DO NOT USE THIS CANDIDATE NUMBER/ );

                # today's vulns only
                #next if ( ($cve{$v}{'vuln:published-datetime'} !~ m/$date_today/) || ($cve{$v}{'vuln:last-modified-datetime'} !~ m/$date_today/) );

                # loop through vendors/products
                foreach my $email ( keys %cpe_settings )
                {
                        foreach my $item ( @{ $cpe_settings{$email} } )
                        {
                                # match vendor/product item from hash with CVE product(s)
                                if ( grep /^${item}/, @{ $cve{$v}{products} } )
                                {
                                        print "[*] $0: INFO $email -> $item\n";

                                        $text = '';
                                        $text .= "ID:             "   . $v . "\n";
                                        $text .= "SUMMARY:        "   . $cve{$v}{'vuln:summary'} . "\n";
                                        $text .= "SCORE:          "   . $cve{$v}{'cvss'}{'cvss:score'} . "\n";
                                        $text .= "PRODUCTS:\n"        . join ( "\n", @{ $cve{$v}{products} } )  . "\n";
                                        $text .= "SOURCES:\n"         . join ( "\n", @{ $cve{$v}{sources} } )   . "\n";
                                        $text .= "REFERENCES:\n"      . join ( "\n", @{ $cve{$v}{urls} } )      . "\n";
                                        $text .= "DATE-PUBLISHED: "   . $cve{$v}{'vuln:published-datetime'}     . "\n";
                                        $text .= "DATE-MODIFIED:  "   . $cve{$v}{'vuln:last-modified-datetime'} . "\n";
                                        $text .= "\n";

                                        print $text;

                                        my %mail = (
                                                     from => 'securityteam@domain.com',
                                                     to => $email . '@domain.com',
                                                     cc => 'securityteam@domain.com',
                                                     subject => "Vulnerability report for hSOFTWARE $item, CVSS ".$cve{$v}{'cvss'}{'cvss:score'}." published $date_today"
                                        );

                                        $mail{body}=$text;
                                        sendmail(%mail) || print "Error in sending email\n";
                                }
                        }
                }
        }
}
